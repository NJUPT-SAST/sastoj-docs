# 评测中间件

为了支持更多的题型、评测机以及评测方式，我们设计了评测中间件。

## 设计思路

题型的评测由独立的微服务或插件来实现。每个题型的微服务或插件包含其自身的业务逻辑、数据模型以及与之相关的评测规则。通过这种方式，新的题型可以独立开发和部署，不会影响到其他题型。

### 独立的数据模型

每个题型服务可以使用自己的数据表来存储特定于该题型的信息，而通用的题目信息（例如标题、题干、分数等）则保存在主题目服务的通用表中。这样一来，当引入新题型时，只需要在对应服务中创建相应的数据模型，而无需对核心题目表进行改动，也即不需要修改获取题目信息的接口和提交评测等接口。

### 独立的业务逻辑

每个题型的服务独立负责其评测逻辑和其他特定的操作。比如本地评测服务处理测试点和判题规则，远程评测服务处理与外部评测系统的交互，手判服务处理人工评审的逻辑。通过这种方式，可以减少不同服务之间的耦合，提高系统的可扩展性和可维护性，为未来引入新的题型提供了便利。

### 信息隔离与安全性

为了避免敏感信息的泄露和减少不必要的前端暴露，建议将敏感数据与前端和管理端隔离。通用的题目信息可以存储在共享的数据库表中，可供前端使用；而每个题型的评测信息（如测试点、远端评测平台信息等）则存储在各自的独立数据库表或服务中，不直接暴露给前端。

## 行为

用户端向评测中间件所有的消息传递都是通过消息队列完成的。评测中间件需要监听消息队列，接收评测请求，进行评测，然后将评测结果按照 `sastoj` 的格式持久化，如果有回调需求，进行回调。

### 初始化

所有题型的提交默认 `Channel` 为 `submission`，中间件在初始化时，需要将自己的所处理的题目类型存入 `problem_type` 表中：

- `name_slug` 为题型内部名称（用于管理端）
- `display_name` 为题型名称（用于用户端）
- `channel_name` 为这种题型所使用的消息队列的 `Channel` 的名字

同时，需要将信息缓存到 `Redis` 中，`Key` 为 `problemType:{name_slug}`，`Value` 为 `Channel` 的名字。

### 接受评测请求

评测机需要监听对应的 `Channel`，并获取评测请求，评测请求的格式为 [`submission`](https://github.com/NJUPT-SAST/sastoj/blob/main/pkg/mq/submission.go)。

### 评测

评测逻辑由中间件自行实现，sastoj 不对评测过程做任何要求。

#### 本地评测

sastoj 现已支持 [`go-judge`](https://github.com/criyle/go-judge) 作为本地评测的评测机。

#### 测试点

sastoj 提供了测试点的支持，测试点文件存放在 `data/cases` 目录下，按照 `problem_id` 分别独立存放。

目前 `sastoj` 的测试点格式为 [rsjudge-test-cases-schema](https://github.com/Jisu-Woniu/rsjudge-test-cases-schema/tree/main/out) 中定义的 `toml` 格式。

### 结果返回

评测机需要将评测结果存入缓存和数据库。数据库连接可以使用 `ent` 也可以使用其他 `ORM` 框架。详见 [提交和自测](./submission-%26-self-test)。
